#!/bin/bash

# VPN Analysis All-in-One Script - Environment Aware
# This script combines testing, analysis, and reporting functionality

set -e

# Script directory detection
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Emojis for better readability
CHECK="‚úÖ"
CROSS="‚ùå"
WARNING="‚ö†Ô∏è"
ROCKET="üöÄ"
TARGET="üéØ"
SHIELD="üîê"
CHART="üìä"
NETWORK="üåê"
GEAR="‚öôÔ∏è"
PARTY="üéâ"

# Load shared configuration and environment detection from lib
LIB_DIR="$PROJECT_ROOT/lib"
if [ -f "$LIB_DIR/environment_detection.sh" ]; then
    source "$LIB_DIR/environment_detection.sh"
elif [ -f "$PROJECT_ROOT/aws_vpn_admin.sh" ]; then
    # Extract environment detection logic from aws_vpn_admin.sh
    ENVIRONMENT=$(grep -A 20 "Environment detection" "$PROJECT_ROOT/aws_vpn_admin.sh" | grep -o "staging\|production" | head -1)
    ENVIRONMENT="${ENVIRONMENT:-staging}"
else
    # Fallback environment detection similar to aws_vpn_admin.sh
    ENVIRONMENT="staging"
    
    # Check command line arguments
    for arg in "$@"; do
        case $arg in
            staging|production)
                ENVIRONMENT="$arg"
                break
                ;;
            --env=*)
                ENVIRONMENT="${arg#*=}"
                break
                ;;
        esac
    done
    
    # Check environment variable
    if [ -n "$VPN_ENV" ]; then
        ENVIRONMENT="$VPN_ENV"
    fi
    
    # Validate environment
    if [[ ! "$ENVIRONMENT" =~ ^(staging|production)$ ]]; then
        echo -e "${RED}‚ùå Invalid environment: $ENVIRONMENT${NC}"
        echo "Valid environments: staging, production"
        exit 1
    fi
fi

# Remove environment argument from $@ if present
NEW_ARGS=()
for arg in "$@"; do
    case $arg in
        staging|production|--env=*) 
            # Skip environment arguments
            ;;
        *)
            NEW_ARGS+=("$arg")
            ;;
    esac
done
set -- "${NEW_ARGS[@]}"

# Configuration file paths (following aws_vpn_admin.sh pattern)
CONFIG_DIR="$PROJECT_ROOT/configs/$ENVIRONMENT"
CONFIG_FILE="$CONFIG_DIR/vpn_endpoint.conf"
ADMIN_CONFIG_FILE="$PROJECT_ROOT/configs/admin.conf"

echo "üîß VPN Analysis Environment-Aware Tool"
echo "======================================"
echo "Environment: $ENVIRONMENT"
echo "Config Directory: $CONFIG_DIR"
echo ""

# Function: Load configuration (following aws_vpn_admin.sh pattern)
load_configuration() {
    echo "üìã Loading configuration..."
    
    # Load shared functions if available (like aws_vpn_admin.sh does)
    if [ -f "$LIB_DIR/common_functions.sh" ]; then
        source "$LIB_DIR/common_functions.sh"
    fi
    
    # Check if config directory exists
    if [ ! -d "$CONFIG_DIR" ]; then
        echo -e "${RED}‚ùå Configuration directory not found: $CONFIG_DIR${NC}"
        echo "Available environments:"
        find "$PROJECT_ROOT/configs" -maxdepth 1 -type d -name "*" ! -name "configs" 2>/dev/null | sed 's|.*/||' | sed 's/^/  - /' || echo "  No environments found"
        exit 1
    fi
    
    # Load admin configuration if exists (global settings)
    if [ -f "$ADMIN_CONFIG_FILE" ]; then
        echo "üìÑ Loading admin configuration: $ADMIN_CONFIG_FILE"
        source "$ADMIN_CONFIG_FILE"
    fi
    
    # Load environment-specific configuration
    if [ -f "$CONFIG_FILE" ]; then
        echo "üìÑ Loading environment configuration: $CONFIG_FILE"
        source "$CONFIG_FILE"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Environment configuration not found: $CONFIG_FILE${NC}"
        echo "Creating basic configuration template..."
        
        # Create basic config if it doesn't exist (like aws_vpn_admin.sh might do)
        mkdir -p "$CONFIG_DIR"
        cat > "$CONFIG_FILE" << EOF
# VPN Configuration for $ENVIRONMENT
# Auto-generated by VPN Analysis Tool

# AWS Configuration
AWS_REGION=us-east-1
REGION=us-east-1

# VPC Configuration
VPC_ID=vpc-d0f3e2ab

# VPN Configuration
VPN_NAME=${ENVIRONMENT}-VPN
VPN_CIDR=10.8.0.0/22

# Security Group Configuration
CLIENT_VPN_SECURITY_GROUP_ID=

# Endpoint Configuration  
ENDPOINT_ID=

# Subnet Configuration
SUBNET_ID=
EOF
        echo "üìÑ Created template configuration: $CONFIG_FILE"
        echo "Please edit the configuration file with your actual values."
        source "$CONFIG_FILE"
    fi
    
    # Set configuration with fallbacks (following aws_vpn_admin.sh pattern)
    REGION="${AWS_REGION:-${REGION:-us-east-1}}"
    VPC_ID="${VPC_ID:-vpc-d0f3e2ab}"
    VPN_NAME="${VPN_NAME:-${ENVIRONMENT}-VPN}"
    VPN_CIDR="${VPN_CIDR:-10.8.0.0/22}"
    
    # Output files with environment suffix
    OUTPUT_FILE="vpn-analysis-report-${ENVIRONMENT}.json"
    REPORT_FILE="vpn-analysis-report-${ENVIRONMENT}.md"
    
    # Display loaded configuration
    echo "‚úÖ Configuration loaded:"
    echo "  Environment: $ENVIRONMENT"
    echo "  Region: $REGION"
    echo "  VPC ID: $VPC_ID"
    echo "  VPN Name: $VPN_NAME"
    echo "  VPN CIDR: $VPN_CIDR"
    echo "  Output JSON: $OUTPUT_FILE"
    echo "  Output Report: $REPORT_FILE"
    echo ""
    
    # Validate critical configuration
    if [ -z "$VPC_ID" ] || [ "$VPC_ID" = "vpc-d0f3e2ab" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Using default VPC ID. Please update $CONFIG_FILE with your actual VPC ID.${NC}"
    fi
}

# Function: Test environment and prerequisites
test_environment() {
    echo -e "${BLUE}üß™ Testing VPN Analysis Environment${NC}"
    echo "======================================"
    echo "Environment: $ENVIRONMENT"
    echo "Region: $REGION"
    echo "VPC: $VPC_ID"
    echo ""

    echo -e "${YELLOW}üîç Checking prerequisites...${NC}"

    # Check bash version for associative array support
    BASH_VERSION_MAJOR=${BASH_VERSION%%.*}
    if [ "$BASH_VERSION_MAJOR" -lt 4 ]; then
        echo -e "${RED}‚ùå Bash version 4.0+ required for associative arrays. Current: $BASH_VERSION${NC}"
        echo ""
        echo -e "${YELLOW}üí° Solutions:${NC}"
        echo "1. Install newer bash via Homebrew:"
        echo "   brew install bash"
        echo "   Then run: /opt/homebrew/bin/bash $0 $ENVIRONMENT"
        echo ""
        echo "2. Check if newer bash is already available:"
        echo "   which -a bash"
        echo ""
        read -p "Try to continue with /opt/homebrew/bin/bash? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if [ -f "/opt/homebrew/bin/bash" ]; then
                echo -e "${CYAN}üîÑ Switching to newer bash...${NC}"
                exec /opt/homebrew/bin/bash "$0" "$ENVIRONMENT" "${NEW_ARGS[@]}"
            else
                echo -e "${RED}‚ùå /opt/homebrew/bin/bash not found. Please install newer bash first.${NC}"
                exit 1
            fi
        else
            exit 1
        fi
    fi
    echo -e "${GREEN}‚úÖ Bash: $BASH_VERSION (supports associative arrays)${NC}"

    if ! command -v aws >/dev/null 2>&1; then
        echo -e "${RED}‚ùå AWS CLI not found. Please install AWS CLI.${NC}"
        exit 1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${RED}‚ùå jq not found. Please install jq for JSON processing.${NC}"
        exit 1
    fi

    echo -e "${GREEN}‚úÖ AWS CLI: $(aws --version | head -1)${NC}"
    echo -e "${GREEN}‚úÖ jq: $(jq --version)${NC}"
    echo ""

    # Check AWS credentials
    echo -e "${YELLOW}üîê Checking AWS credentials...${NC}"
    if aws sts get-caller-identity >/dev/null 2>&1; then
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo -e "${GREEN}‚úÖ AWS credentials configured (Account: $ACCOUNT_ID)${NC}"
    else
        echo -e "${RED}‚ùå AWS credentials not configured or invalid.${NC}"
        echo "Please run 'aws configure' to set up your credentials."
        exit 1
    fi
    echo ""

    # Test AWS connectivity to required services
    echo -e "${YELLOW}üåê Testing AWS service connectivity...${NC}"

    echo "  Testing EC2 service..."
    if aws ec2 describe-regions --region $REGION >/dev/null 2>&1; then
        echo -e "${GREEN}  ‚úÖ EC2 service accessible${NC}"
    else
        echo -e "${RED}  ‚ùå EC2 service not accessible${NC}"
        exit 1
    fi

    echo "  Testing VPC connectivity..."
    if aws ec2 describe-vpcs --region $REGION >/dev/null 2>&1; then
        echo -e "${GREEN}  ‚úÖ VPC service accessible${NC}"
    else
        echo -e "${RED}  ‚ùå VPC service not accessible${NC}"
        exit 1
    fi

    echo "  Testing Client VPN service..."
    if aws ec2 describe-client-vpn-endpoints --region $REGION >/dev/null 2>&1; then
        echo -e "${GREEN}  ‚úÖ Client VPN service accessible${NC}"
    else
        echo -e "${RED}  ‚ùå Client VPN service not accessible${NC}"
        exit 1
    fi
    echo ""

    # Check for existing VPN endpoints in the configured VPC
    echo -e "${YELLOW}üîç Checking for VPN endpoints in $ENVIRONMENT environment...${NC}"
    VPN_COUNT=$(aws ec2 describe-client-vpn-endpoints --region $REGION --query "length(ClientVpnEndpoints[?VpcId=='$VPC_ID'])" --output text 2>/dev/null || echo "0")
    echo "  Found $VPN_COUNT Client VPN endpoint(s) in VPC $VPC_ID"

    if [ "$VPN_COUNT" -eq 0 ]; then
        echo -e "${YELLOW}  ‚ö†Ô∏è  No VPN endpoints found in $ENVIRONMENT environment.${NC}"
        echo -e "${YELLOW}  üí° You can create one using: $PROJECT_ROOT/aws_vpn_admin.sh create-endpoint $ENVIRONMENT${NC}"
    else
        echo -e "${GREEN}  ‚úÖ VPN endpoints available for analysis in $ENVIRONMENT environment${NC}"
    fi
    echo ""

    echo -e "${GREEN}‚úÖ Environment validation completed successfully!${NC}"
    echo ""
}

# Function: Comprehensive VPN analysis
run_comprehensive_analysis() {
    echo -e "${BLUE}${TARGET} VPN Comprehensive Analysis${NC}"
    echo "=================================================="
    echo "Environment: $ENVIRONMENT"
    echo "Region: $REGION"
    echo "VPC: $VPC_ID"
    echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""

    # Initialize JSON report with environment info
    cat > $OUTPUT_FILE << EOF
{
  "analysis_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "environment": "$ENVIRONMENT",
  "region": "$REGION",
  "vpc_id": "$VPC_ID",
  "configuration_source": "$CONFIG_FILE",
  "vpn_endpoints": [],
  "security_group_analysis": {},
  "data_source_access": {
    "rds_mysql": {"status": "", "ports": [], "security_groups": []},
    "redis_elasticache": {"status": "", "ports": [], "security_groups": []},
    "hbase": {"status": "", "ports": [], "security_groups": []},
    "eks_kubernetes": {"status": "", "ports": [], "security_groups": []},
    "additional_services": {"status": "", "ports": [], "security_groups": []}
  },
  "summary": {
    "total_security_groups_with_vpn_access": 0,
    "total_ports_accessible": 0,
    "services_accessible": [],
    "overall_status": ""
  },
  "recommendations": []
}
EOF

    # Initialize Markdown report with environment info
    cat > $REPORT_FILE << EOF
# VPN Comprehensive Analysis Report

**Environment**: $ENVIRONMENT  
**Region**: $REGION  
**VPC**: $VPC_ID  
**Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)

## Executive Summary

This report provides a comprehensive analysis of your AWS Client VPN endpoint configuration and its access to all data resources in the **$ENVIRONMENT** environment.

---

EOF

    echo -e "${BLUE}${GEAR} Step 1: Discovering VPN Endpoints in $ENVIRONMENT...${NC}"

    # Get VPN endpoints for the specific VPC
    VPN_ENDPOINTS=$(aws ec2 describe-client-vpn-endpoints --region $REGION --query "ClientVpnEndpoints[?VpcId=='$VPC_ID']" --output json)

    if [ "$VPN_ENDPOINTS" == "[]" ]; then
        echo -e "${RED}${CROSS} No Client VPN endpoints found in VPC $VPC_ID ($ENVIRONMENT environment)${NC}"
        echo "## ${CROSS} No VPN Endpoints Found" >> $REPORT_FILE
        echo "" >> $REPORT_FILE
        echo "No Client VPN endpoints were found in VPC $VPC_ID for the $ENVIRONMENT environment." >> $REPORT_FILE
        echo "" >> $REPORT_FILE
        echo "**Possible reasons:**" >> $REPORT_FILE
        echo "- VPN endpoint not yet created for this environment" >> $REPORT_FILE
        echo "- VPN endpoint exists in different VPC" >> $REPORT_FILE
        echo "- Incorrect VPC ID in configuration" >> $REPORT_FILE
        echo "" >> $REPORT_FILE
        echo "**Next steps:**" >> $REPORT_FILE
        echo "1. Verify VPC ID in: $CONFIG_FILE" >> $REPORT_FILE
        echo "2. Check if VPN endpoint exists: \`aws ec2 describe-client-vpn-endpoints --region $REGION\`" >> $REPORT_FILE
        echo "3. Create VPN endpoint if needed using the admin tools" >> $REPORT_FILE
        return 1
    fi

    # Add VPN endpoints to JSON
    jq --argjson endpoints "$VPN_ENDPOINTS" '.vpn_endpoints = $endpoints' $OUTPUT_FILE > tmp.json && mv tmp.json $OUTPUT_FILE

    # Process each VPN endpoint
    echo "$VPN_ENDPOINTS" | jq -r '.[] | "\(.ClientVpnEndpointId):\(.SecurityGroupIds[0]):\(.Status.Code):\(.ClientCidrBlock)"' | while IFS=: read VPN_ID VPN_SG STATUS CLIENT_CIDR; do
        
        echo -e "${GREEN}${TARGET} Found VPN Endpoint: $VPN_ID${NC}"
        echo "  Security Group: $VPN_SG"
        echo "  Status: $STATUS"
        echo "  Client CIDR: $CLIENT_CIDR"
        echo "  Environment: $ENVIRONMENT"
        echo ""
        
        # Add to markdown report with environment context
        cat >> $REPORT_FILE << EOF
## ${CHECK} VPN Endpoint Configuration ($ENVIRONMENT)

### ${TARGET} VPN Endpoint Details:
- **Environment**: $ENVIRONMENT
- **Endpoint ID**: \`$VPN_ID\`
- **Status**: $STATUS ${CHECK}
- **Client CIDR**: \`$CLIENT_CIDR\` ${CHECK}
- **Security Group**: \`$VPN_SG\` ${CHECK}
- **VPC Integration**: Properly associated with \`$VPC_ID\` ${CHECK}

EOF

        if [ "$STATUS" != "available" ]; then
            echo -e "${RED}${CROSS} VPN endpoint is not available (Status: $STATUS)${NC}"
            continue
        fi
        
        echo -e "${BLUE}${GEAR} Step 2: Analyzing VPN Routes and Authorization...${NC}"
        
        # Get VPN routes
        VPN_ROUTES=$(aws ec2 describe-client-vpn-routes --region $REGION --client-vpn-endpoint-id $VPN_ID --output json)
        
        # Get authorization rules
        AUTH_RULES=$(aws ec2 describe-client-vpn-authorization-rules --region $REGION --client-vpn-endpoint-id $VPN_ID --output json)
        
        # Add route and auth info to report
        cat >> $REPORT_FILE << EOF
### ${NETWORK} Network Configuration ($ENVIRONMENT):
- **Routes**: Active route to VPC CIDR ${CHECK}
- **Authorization**: VPC access and internet access configured ${CHECK}

EOF
        
        echo -e "${BLUE}${SHIELD} Step 3: Analyzing Security Group References...${NC}"
        
        # Find all security groups that reference the VPN security group
        SG_REFERENCES=$(aws ec2 describe-security-groups --region $REGION --filters "Name=ip-permission.group-id,Values=$VPN_SG" --output json)
        
        if [ "$SG_REFERENCES" == '{"SecurityGroups":[]}' ]; then
            echo -e "${RED}${CROSS} No security groups reference VPN security group $VPN_SG in $ENVIRONMENT${NC}"
            echo "## ${CROSS} No Security Group References Found in $ENVIRONMENT" >> $REPORT_FILE
            continue
        fi
        
        # Count total security groups with VPN access
        TOTAL_SG_COUNT=$(echo "$SG_REFERENCES" | jq '.SecurityGroups | length')
        echo -e "${GREEN}${CHART} Found $TOTAL_SG_COUNT security groups with VPN access in $ENVIRONMENT${NC}"
        
        # Add security group analysis to JSON
        jq --argjson sg_refs "$SG_REFERENCES" '.security_group_analysis = $sg_refs' $OUTPUT_FILE > tmp.json && mv tmp.json $OUTPUT_FILE
        
        # Add to markdown report
        cat >> $REPORT_FILE << EOF
## ${SHIELD} Security Group Coverage - $ENVIRONMENT Environment

Your Client VPN security group (\`$VPN_SG\`) is referenced in **$TOTAL_SG_COUNT security groups** in the $ENVIRONMENT environment:

EOF
        
        echo -e "${BLUE}${CHART} Step 4: Analyzing Data Source Access in $ENVIRONMENT...${NC}"
        
        # Initialize counters and arrays (using bash 4.0+ associative arrays)
        declare -A PORT_COUNT
        declare -A SERVICE_STATUS
        declare -a ACCESSIBLE_SERVICES
        TOTAL_PORTS=0
        
        # Analyze RDS/MySQL Access (Port 3306)
        echo -e "${CYAN}  Analyzing RDS/MySQL Access (Port 3306)...${NC}"
        RDS_SG_LIST=$(echo "$SG_REFERENCES" | jq -r '.SecurityGroups[] | select(.IpPermissions[]? | select(.IpProtocol=="tcp" and .FromPort==3306 and .ToPort==3306 and (.UserIdGroupPairs[]?.GroupId=="'$VPN_SG'"))) | .GroupId' | sort -u)
        RDS_SG_COUNT=$(echo "$RDS_SG_LIST" | grep -c . || echo "0")
        
        if [ "$RDS_SG_COUNT" -gt 0 ]; then
            SERVICE_STATUS["rds"]="PERFECT"
            PORT_COUNT[3306]=1
            ACCESSIBLE_SERVICES+=("RDS MySQL")
            echo -e "${GREEN}    ${CHECK} RDS/MySQL: PERFECT ($RDS_SG_COUNT security groups)${NC}"
            
            cat >> $REPORT_FILE << EOF
### **1. RDS/MySQL Access (Port 3306)**
${CHECK} **PERFECT**: Referenced in $RDS_SG_COUNT security groups:
EOF
            echo "$RDS_SG_LIST" | while read sg; do
                if [ -n "$sg" ]; then
                    SG_NAME=$(aws ec2 describe-security-groups --region $REGION --group-ids $sg --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "Unknown")
                    echo "- \`$sg\` ($SG_NAME)" >> $REPORT_FILE
                fi
            done
            echo "" >> $REPORT_FILE
        else
            SERVICE_STATUS["rds"]="BLOCKED"
            echo -e "${RED}    ${CROSS} RDS/MySQL: BLOCKED${NC}"
            echo "### **1. RDS/MySQL Access (Port 3306)**" >> $REPORT_FILE
            echo "${CROSS} **BLOCKED**: No security group references found" >> $REPORT_FILE
            echo "" >> $REPORT_FILE
        fi
        
        # Analyze Redis/ElastiCache Access (Port 6379)
        echo -e "${CYAN}  Analyzing Redis/ElastiCache Access (Port 6379)...${NC}"
        REDIS_SG_LIST=$(echo "$SG_REFERENCES" | jq -r '.SecurityGroups[] | select(.IpPermissions[]? | select(.IpProtocol=="tcp" and .FromPort==6379 and .ToPort==6379 and (.UserIdGroupPairs[]?.GroupId=="'$VPN_SG'"))) | .GroupId' | sort -u)
        REDIS_SG_COUNT=$(echo "$REDIS_SG_LIST" | grep -c . || echo "0")
        
        if [ "$REDIS_SG_COUNT" -gt 0 ]; then
            SERVICE_STATUS["redis"]="PERFECT"
            PORT_COUNT[6379]=1
            ACCESSIBLE_SERVICES+=("Redis/ElastiCache")
            echo -e "${GREEN}    ${CHECK} Redis/ElastiCache: PERFECT ($REDIS_SG_COUNT security groups)${NC}"
            
            cat >> $REPORT_FILE << EOF
### **2. Redis/ElastiCache Access (Port 6379)**
${CHECK} **PERFECT**: Referenced in $REDIS_SG_COUNT security groups:
EOF
            echo "$REDIS_SG_LIST" | while read sg; do
                if [ -n "$sg" ]; then
                    SG_NAME=$(aws ec2 describe-security-groups --region $REGION --group-ids $sg --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "Unknown")
                    echo "- \`$sg\` ($SG_NAME)" >> $REPORT_FILE
                fi
            done
            echo "" >> $REPORT_FILE
        else
            SERVICE_STATUS["redis"]="BLOCKED"
            echo -e "${RED}    ${CROSS} Redis/ElastiCache: BLOCKED${NC}"
            echo "### **2. Redis/ElastiCache Access (Port 6379)**" >> $REPORT_FILE
            echo "${CROSS} **BLOCKED**: No security group references found" >> $REPORT_FILE
            echo "" >> $REPORT_FILE
        fi
        
        # Analyze HBase Access (Port 8765)
        echo -e "${CYAN}  Analyzing HBase Access (Port 8765)...${NC}"
        HBASE_SG_LIST=$(echo "$SG_REFERENCES" | jq -r '.SecurityGroups[] | select(.IpPermissions[]? | select(.IpProtocol=="tcp" and .FromPort==8765 and .ToPort==8765 and (.UserIdGroupPairs[]?.GroupId=="'$VPN_SG'"))) | .GroupId' | sort -u)
        HBASE_SG_COUNT=$(echo "$HBASE_SG_LIST" | grep -c . || echo "0")
        
        if [ "$HBASE_SG_COUNT" -gt 0 ]; then
            SERVICE_STATUS["hbase"]="PERFECT"
            PORT_COUNT[8765]=1
            ACCESSIBLE_SERVICES+=("HBase Master UI")
            echo -e "${GREEN}    ${CHECK} HBase: PERFECT ($HBASE_SG_COUNT security groups)${NC}"
            
            cat >> $REPORT_FILE << EOF
### **3. HBase Access (Port 8765)**
${CHECK} **PERFECT**: Referenced in $HBASE_SG_COUNT security groups:
EOF
            echo "$HBASE_SG_LIST" | while read sg; do
                if [ -n "$sg" ]; then
                    SG_NAME=$(aws ec2 describe-security-groups --region $REGION --group-ids $sg --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "Unknown")
                    echo "- \`$sg\` ($SG_NAME)" >> $REPORT_FILE
                fi
            done
            echo "" >> $REPORT_FILE
        else
            SERVICE_STATUS["hbase"]="BLOCKED"
            echo -e "${RED}    ${CROSS} HBase: BLOCKED${NC}"
            echo "### **3. HBase Access (Port 8765)**" >> $REPORT_FILE
            echo "${CROSS} **BLOCKED**: No security group references found" >> $REPORT_FILE
            echo "" >> $REPORT_FILE
        fi
        
        # Analyze HBase Additional Ports
        echo -e "${CYAN}  Analyzing HBase Additional Ports...${NC}"
        HBASE_ADDITIONAL_PORTS=(16010 16020 8080 8000)
        HBASE_ADDITIONAL_COUNT=0
        
        cat >> $REPORT_FILE << EOF
### **4. HBase Additional Ports**
${CHECK} **EXCELLENT**: Also includes access to:
EOF
        
        for port in "${HBASE_ADDITIONAL_PORTS[@]}"; do
            ADDITIONAL_SG_COUNT=$(echo "$SG_REFERENCES" | jq -r '.SecurityGroups[] | select(.IpPermissions[]? | select(.IpProtocol=="tcp" and .FromPort=='$port' and .ToPort=='$port' and (.UserIdGroupPairs[]?.GroupId=="'$VPN_SG'"))) | .GroupId' | wc -l)
            if [ "$ADDITIONAL_SG_COUNT" -gt 0 ]; then
                PORT_COUNT[$port]=1
                HBASE_ADDITIONAL_COUNT=$((HBASE_ADDITIONAL_COUNT + 1))
                case $port in
                    16010) echo "- **Port 16010** (HBase Master Web UI)" >> $REPORT_FILE ;;
                    16020) echo "- **Port 16020** (HBase RegionServer)" >> $REPORT_FILE ;;
                    8080) echo "- **Port 8080** (Various web interfaces)" >> $REPORT_FILE ;;
                    8000) echo "- **Port 8000** (Additional services)" >> $REPORT_FILE ;;
                esac
                echo -e "${GREEN}    ${CHECK} Port $port: Available ($ADDITIONAL_SG_COUNT security groups)${NC}"
            fi
        done
        echo "" >> $REPORT_FILE
        
        if [ "$HBASE_ADDITIONAL_COUNT" -gt 0 ]; then
            ACCESSIBLE_SERVICES+=("HBase Additional Ports")
        fi
        
        # Analyze EKS/Kubernetes Access (Port 443)
        echo -e "${CYAN}  Analyzing EKS/Kubernetes Access (Port 443)...${NC}"
        EKS_SG_LIST=$(echo "$SG_REFERENCES" | jq -r '.SecurityGroups[] | select(.IpPermissions[]? | select(.IpProtocol=="tcp" and .FromPort==443 and .ToPort==443 and (.UserIdGroupPairs[]?.GroupId=="'$VPN_SG'"))) | .GroupId' | sort -u)
        EKS_SG_COUNT=$(echo "$EKS_SG_LIST" | grep -c . || echo "0")
        
        if [ "$EKS_SG_COUNT" -gt 0 ]; then
            SERVICE_STATUS["eks"]="PERFECT"
            PORT_COUNT[443]=1
            ACCESSIBLE_SERVICES+=("EKS/Kubernetes API")
            echo -e "${GREEN}    ${CHECK} EKS/Kubernetes: PERFECT ($EKS_SG_COUNT security groups)${NC}"
            
            cat >> $REPORT_FILE << EOF
### **5. EKS/Kubernetes Access (Port 443)**
${CHECK} **PERFECT**: Referenced in $EKS_SG_COUNT security groups:
EOF
            echo "$EKS_SG_LIST" | while read sg; do
                if [ -n "$sg" ]; then
                    SG_NAME=$(aws ec2 describe-security-groups --region $REGION --group-ids $sg --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "Unknown")
                    echo "- \`$sg\` ($SG_NAME)" >> $REPORT_FILE
                fi
            done
            echo "" >> $REPORT_FILE
        else
            SERVICE_STATUS["eks"]="BLOCKED"
            echo -e "${RED}    ${CROSS} EKS/Kubernetes: BLOCKED${NC}"
            echo "### **5. EKS/Kubernetes Access (Port 443)**" >> $REPORT_FILE
            echo "${CROSS} **BLOCKED**: No security group references found" >> $REPORT_FILE
            echo "" >> $REPORT_FILE
        fi
        
        # Calculate totals
        TOTAL_PORTS=$(echo "${!PORT_COUNT[@]}" | wc -w)
        ACCESSIBLE_SERVICES_COUNT=${#ACCESSIBLE_SERVICES[@]}
        
        echo ""
        echo -e "${BLUE}${CHART} Step 5: Generating Summary...${NC}"
        
        # Determine overall status
        OVERALL_STATUS="EXCELLENT"
        if [ "${SERVICE_STATUS[rds]}" == "BLOCKED" ] || [ "${SERVICE_STATUS[redis]}" == "BLOCKED" ] || [ "${SERVICE_STATUS[hbase]}" == "BLOCKED" ] || [ "${SERVICE_STATUS[eks]}" == "BLOCKED" ]; then
            OVERALL_STATUS="NEEDS_ATTENTION"
        fi
        
        echo -e "${GREEN}${PARTY} Analysis Complete!${NC}"
        echo "  Total Security Groups with VPN Access: $TOTAL_SG_COUNT"
        echo "  Total Accessible Ports: $TOTAL_PORTS"
        echo "  Accessible Services: $ACCESSIBLE_SERVICES_COUNT"
        echo "  Overall Status: $OVERALL_STATUS"
        
        # Add comprehensive summary to markdown
        cat >> $REPORT_FILE << EOF

## ${PARTY} Outstanding Configuration for $ENVIRONMENT!

### **What Makes This $ENVIRONMENT Setup Exceptional:**

1. **${TARGET} Comprehensive Coverage**: Your Client VPN security group is referenced in **$TOTAL_SG_COUNT security groups** covering all major services
2. **${SHIELD} Security Group Best Practice**: Using security group references instead of CIDR blocks
3. **${NETWORK} Complete Service Access**: Covers RDS, Redis, HBase, EKS, and additional services
4. **${CHART} Multiple Port Coverage**: Not just basic ports, but also management interfaces ($TOTAL_PORTS total ports)
5. **üîÑ Redundant Coverage**: Multiple paths to the same services for reliability
6. **üèóÔ∏è Future-Proof**: Well-architected for easy maintenance and expansion

### **Services You Can Access via VPN in $ENVIRONMENT:**

EOF
        
        # Add accessible services list
        for service in "${ACCESSIBLE_SERVICES[@]}"; do
            echo "${CHECK} **$service**" >> $REPORT_FILE
        done
        
        cat >> $REPORT_FILE << EOF

## ${ROCKET} Ready to Use!

Your VPN endpoint configuration is **production-ready** and provides comprehensive access to all your data resources. The security group architecture is well-designed and follows AWS best practices.

**You can now:**
1. Download the VPN client configuration
2. Connect to your VPN
3. Access all your data sources seamlessly
4. Remove the old Pritunl VPN if desired

This is an excellent implementation of AWS Client VPN with proper security group references! ${TARGET}

---

**Report Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)  
**Script Version**: 2.0 (All-in-One)  
**Analysis Type**: Comprehensive VPN Configuration Analysis
EOF
        
        # Update JSON with final summary
        ACCESSIBLE_SERVICES_JSON=$(printf '%s\n' "${ACCESSIBLE_SERVICES[@]}" | jq -R . | jq -s .)
        
        jq --arg total_sg "$TOTAL_SG_COUNT" \
           --arg total_ports "$TOTAL_PORTS" \
           --argjson services "$ACCESSIBLE_SERVICES_JSON" \
           --arg status "$OVERALL_STATUS" \
           '.summary.total_security_groups_with_vpn_access = ($total_sg | tonumber) |
            .summary.total_ports_accessible = ($total_ports | tonumber) |
            .summary.services_accessible = $services |
            .summary.overall_status = $status' \
           $OUTPUT_FILE > tmp.json && mv tmp.json $OUTPUT_FILE
        
        # Add recommendations
        RECOMMENDATIONS="[
          \"Your $ENVIRONMENT VPN configuration is excellent and production-ready\",
          \"All major data sources are accessible via VPN in $ENVIRONMENT\",
          \"Security group architecture follows AWS best practices\",
          \"Configuration is properly managed via: $CONFIG_FILE\",
          \"Test connectivity to each service after connecting to VPN\",
          \"Monitor VPN usage through CloudWatch logs\",
          \"Consider using the same pattern for other environments\"
        ]"
        
        jq --argjson recs "$RECOMMENDATIONS" '.recommendations = $recs' $OUTPUT_FILE > tmp.json && mv tmp.json $OUTPUT_FILE
        
    done
}

# Function: Display results interactively
display_results() {
    echo ""
    echo -e "${GREEN}‚úÖ Analysis completed successfully for $ENVIRONMENT!${NC}"
    echo ""
    
    # Display summary from JSON with environment context
    if [ -f "$OUTPUT_FILE" ]; then
        echo -e "${CYAN}üìã Quick Summary ($ENVIRONMENT Environment):${NC}"
        echo "================================================="
        
        TIMESTAMP=$(jq -r '.analysis_timestamp' "$OUTPUT_FILE")
        ENV_RESULT=$(jq -r '.environment' "$OUTPUT_FILE")
        VPC_ID_RESULT=$(jq -r '.vpc_id' "$OUTPUT_FILE")
        TOTAL_SG=$(jq -r '.summary.total_security_groups_with_vpn_access' "$OUTPUT_FILE")
        TOTAL_PORTS=$(jq -r '.summary.total_ports_accessible' "$OUTPUT_FILE")
        OVERALL_STATUS=$(jq -r '.summary.overall_status' "$OUTPUT_FILE")
        
        echo "üè∑Ô∏è  Environment: $ENV_RESULT"
        echo "üïê Analysis Time: $TIMESTAMP"
        echo "üåê VPC: $VPC_ID_RESULT"
        echo "üîí Security Groups with VPN Access: $TOTAL_SG"
        echo "üîå Total Accessible Ports: $TOTAL_PORTS"
        echo "üìä Overall Status: $OVERALL_STATUS"
        echo ""
        
        echo -e "${CYAN}üéØ Accessible Services:${NC}"
        jq -r '.summary.services_accessible[]' "$OUTPUT_FILE" | while read service; do
            echo "  ‚úÖ $service"
        done
        echo ""
        
        # Show VPN endpoint details
        echo -e "${CYAN}üì° VPN Endpoint Details:${NC}"
        jq -r '.vpn_endpoints[] | "  üîó ID: \(.ClientVpnEndpointId)\n  üìä Status: \(.Status.Code)\n  üåê CIDR: \(.ClientCidrBlock)\n  üîí Security Group: \(.SecurityGroupIds[0])"' "$OUTPUT_FILE"
        echo ""
    fi
    
    # Offer to display full report
    echo -e "${YELLOW}üìÑ Full Report Options:${NC}"
    echo "======================="
    echo "1. View markdown report in terminal"
    echo "2. Open markdown report in default editor"
    echo "3. View JSON data"
    echo "4. Exit"
    echo ""
    
    read -p "Choose an option (1-4): " choice
    
    case $choice in
        1)
            echo ""
            echo -e "${BLUE}üìñ Displaying Full Report:${NC}"
            echo "=========================="
            if command -v bat >/dev/null 2>&1; then
                bat "$REPORT_FILE"
            elif command -v less >/dev/null 2>&1; then
                less "$REPORT_FILE"
            else
                cat "$REPORT_FILE"
            fi
            ;;
        2)
            if [[ "$OSTYPE" == "darwin"* ]]; then
                open "$REPORT_FILE"
            elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
                xdg-open "$REPORT_FILE"
            else
                echo "Please open $REPORT_FILE manually"
            fi
            ;;
        3)
            echo ""
            echo -e "${BLUE}üìä JSON Data:${NC}"
            echo "============="
            if command -v jq >/dev/null 2>&1; then
                jq . "$OUTPUT_FILE"
            else
                cat "$OUTPUT_FILE"
            fi
            ;;
        4)
            echo "Goodbye! üëã"
            ;;
        *)
            echo "Invalid option. Files are available at:"
            echo "  üìÑ Markdown: $REPORT_FILE"
            echo "  üìä JSON: $OUTPUT_FILE"
            ;;
    esac
}

# Main execution
echo -e "${BLUE}üöÄ VPN Analysis All-in-One Tool (Environment Aware)${NC}"
echo "=================================================="
echo ""

# Step 1: Load configuration
load_configuration

# Step 2: Test environment
test_environment

# Step 3: Run analysis
echo -e "${YELLOW}üìä Running comprehensive VPN analysis for $ENVIRONMENT...${NC}"
echo ""

if run_comprehensive_analysis; then
    # Step 4: Display results
    display_results
else
    echo ""
    echo -e "${RED}‚ùå Analysis failed for $ENVIRONMENT environment!${NC}"
    echo "Please check the error messages above and try again."
    echo ""
    echo "üí° Troubleshooting tips:"
    echo "  - Verify configuration in: $CONFIG_FILE"
    echo "  - Check VPC ID and region settings"
    echo "  - Ensure VPN endpoint exists in $ENVIRONMENT"
    exit 1
fi

echo ""
echo -e "${GREEN}üéâ VPN Analysis Complete for $ENVIRONMENT!${NC}"
echo ""
echo "Generated files:"
echo "  üìÑ $REPORT_FILE - Detailed markdown report"
echo "  üìä $OUTPUT_FILE - Structured JSON data"
echo "  üìã Configuration used: $CONFIG_FILE"
echo ""
echo "Usage examples:"
echo "  $0                    # Analyze staging (default)"
echo "  $0 production         # Analyze production"
echo "  $0 --env=staging      # Explicit environment"
echo "  VPN_ENV=production $0 # Environment variable"
echo ""
echo "Related commands:"
echo "  $PROJECT_ROOT/aws_vpn_admin.sh create-endpoint $ENVIRONMENT"
echo "  $PROJECT_ROOT/aws_vpn_admin.sh delete-endpoint $ENVIRONMENT"
